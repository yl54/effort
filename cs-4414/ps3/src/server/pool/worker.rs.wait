use std::collections::HashMap;
use std::io::{BufRead, BufReader, Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::sync::mpsc::{Receiver, Sender};

use server::http::{HHeader, HRequest};

pub type Callback = fn(HRequest);

struct Handler {
    // path is the url path.
    path: String,

    // handler is the function to execute.
    handler: Callback,

    // count is the number of times this handler has been requested.
    count: Arc<Mutex<u16>>,
}

// worker struct
pub struct Worker {
    rx_pipe: Receiver<HRequest>,

    // handlers is a hashmap from the url path to handler functions.    
    handlers: HashMap<String, Handler>,
}

// worker impl
impl Worker {
    pub fn new(rx: Receiver<HRequest>) -> Worker {
        Worker {
            rx_pipe: rx,
            handlers: HashMap::new(),
        }
    }

    // function to handle request
    pub fn wait_and_handle(&self) {
        // Do infinite loop

            // Check if anything has popped out of queue

            // If something out, then handle
    }

    fn handle(&self, req: HRequest) {
        let cl_req = req.clone();
        let path = match cl_req.path {
            Some(p) => p,
            None => {
                debug!("Failed getting the path from the request.");
                return
            },
        };
    
        match self.handlers.get(&path.to_string()) {
            Some(h) => { 
                (h.handler)(req);
                let mut c = h.count.lock().unwrap();
                *c += 1;
            },
            None => {
                //handlers::handle_default(stream); 
            },
        }
    }
}